package src.ui {		import flash.display.Sprite;	import flash.display.Stage;		import flash.display.GradientType;	import flash.display.SpreadMethod;	import flash.geom.Matrix;		import flash.events.Event;	import flash.events.MouseEvent;		import flash.net.NetStream;		import src.ui.ScrubButton;	import src.events.VideoScrubEvent;	import flash.media.Video;		public class ScrubBar extends Sprite {				private var thisWidth:Number;		private var thisHeight:Number;		private var scrubButtonWidth:Number;				private var colors:Array;		private var alphas:Array;		private var ratios:Array;		private var matrix:Matrix;				private var currentProgress:Number;		private var progressWidth:Number;				// BUFFER BAR				private var bufferBar:Sprite;		private var bufferWidth:Number;		private var bufferOrigin:Number;				// PROGRESS BAR				private var progressBar:Sprite;		private var progressFill:Sprite;				private var scrubButton:ScrubButton;				private var previousX:Number;		private var currentX:Number;				private var shouldUpdate:Boolean;		private var isScrubbing:Boolean;				private var maxX:Number;		public function ScrubBar(tWidth:Number) {						thisWidth = tWidth;			thisHeight = 15;						colors = [0xbf0000, 0x720000];			alphas = [1, 1];			ratios = [0, 1];			matrix = new Matrix();			matrix.createGradientBox(thisWidth, thisHeight, Math.PI/2, 0, 0);						shouldUpdate = true;			isScrubbing = false;						scrubButtonWidth = 40;						progressWidth = 0;			bufferWidth = 0;			bufferOrigin = 0;						progressBar = new Sprite();			redrawBackground();			progressBar.alpha = 0.8;						bufferBar = new Sprite();			redrawBuffer();			bufferBar.alpha = 0.8;						progressFill = new Sprite();			redrawProgress();						scrubButton = new ScrubButton();			scrubButton.addEventListener(MouseEvent.MOUSE_DOWN, onDragDown);						addChild(progressBar);			addChild(bufferBar);			addChild(progressFill);			addChild(scrubButton);						addEventListener(Event.ADDED_TO_STAGE, addedToStage);			addEventListener(MouseEvent.CLICK, clickHandler);		}				public function reset():void {			scrubButton.x = 0;			progressWidth = 0;			currentProgress = 0;			redrawProgress();		}				private function addedToStage(e:Event):void {			stage.addEventListener(MouseEvent.MOUSE_UP, onDragUp);		}				private function clickHandler(e:MouseEvent):void {						scrubButton.x = mouseX - (scrubButton.buttonWidth/2);						maxX = thisWidth - scrubButtonWidth;						if (scrubButton.x <= 0) {				scrubButton.x = 0;			}						if (scrubButton.x >= maxX) {				scrubButton.x = maxX;			}						progressWidth = scrubButton.x + (scrubButtonWidth/2);			redrawProgress();						currentProgress = (scrubButton.x / maxX);			dispatchEvent(new VideoScrubEvent(VideoScrubEvent.VIDEO_SCRUB, currentProgress));						if (scrubButton.x < bufferOrigin || scrubButton.x > (bufferOrigin + bufferWidth)) {				bufferWidth = 0;			}						bufferOrigin = scrubButton.x + (scrubButton.buttonWidth/2);						previousX = mouseX;							e.updateAfterEvent();		}				private function onDragDown(e:MouseEvent):void {						isScrubbing = true;			shouldUpdate = false;						previousX = mouseX;						stage.addEventListener(MouseEvent.MOUSE_MOVE, onDragMove);		}				private function onDragUp(e:MouseEvent):void {			isScrubbing = false;			stage.removeEventListener(MouseEvent.MOUSE_MOVE, onDragMove);						maxX = thisWidth - scrubButtonWidth;						progressWidth = scrubButton.x + (scrubButtonWidth/2);						currentProgress = (scrubButton.x / maxX);						dispatchEvent(new VideoScrubEvent(VideoScrubEvent.VIDEO_SCRUB, currentProgress));			dispatchEvent(new VideoScrubEvent(VideoScrubEvent.VIDEO_SCRUBBED));		}				private function onDragMove(e:MouseEvent):void {						scrubButton.x = scrubButton.x + (mouseX - previousX);						maxX = thisWidth - scrubButtonWidth;						if (scrubButton.x <= 0) {				scrubButton.x = 0;			}						if (scrubButton.x >= maxX) {				scrubButton.x = maxX;			}						progressWidth = scrubButton.x + (scrubButtonWidth/2);			redrawProgress();						currentProgress = (scrubButton.x / maxX);			//dispatchEvent(new VideoScrubEvent(VideoScrubEvent.VIDEO_SCRUB, currentProgress));						if (scrubButton.x < bufferOrigin || scrubButton.x > (bufferOrigin + bufferWidth)) {				bufferWidth = 0;			}						bufferOrigin = scrubButton.x + (scrubButton.buttonWidth/2);						previousX = mouseX;							e.updateAfterEvent();		}				public function format(tWidth:Number):void {						thisWidth = tWidth;						redrawBackground();		}				public function update(prog:String):void {						currentProgress = parseFloat(prog);			maxX = thisWidth - scrubButtonWidth;						if (isScrubbing == false) {								scrubButton.x = currentProgress * maxX;				bufferOrigin = scrubButton.x;				progressWidth = (currentProgress * maxX) + (scrubButtonWidth/2);				redrawProgress();				redrawBuffer();			}		}				public function updateLoaded(loaded:Number):void {			bufferWidth = loaded * thisWidth;			redrawBuffer();		}				private function redrawProgress():void {						with (progressFill.graphics) {				clear();				beginGradientFill(GradientType.LINEAR, colors, alphas, ratios, matrix, SpreadMethod.PAD);				drawRect(0, 0, progressWidth, thisHeight);				endFill();			}		}				private function redrawBuffer():void {						bufferBar.x = bufferOrigin;			with (bufferBar.graphics) {				clear();				beginFill(0xc85f5f);				drawRect(0, 0, bufferWidth, thisHeight);				endFill();			}		}				private function redrawBackground():void {						with (progressBar.graphics) {				clear();				beginFill(0x8B8B8B);				drawRect(0, 0, thisWidth, thisHeight);				endFill();			}		}	}	}