package src.video {		import flash.display.Sprite;		import flash.media.Video;	import flash.media.SoundTransform;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.events.Event;		import flash.events.NetStatusEvent;	import flash.events.AsyncErrorEvent;	import flash.events.SecurityErrorEvent;	import flash.events.IOErrorEvent;	import flash.system.Capabilities;		import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.navigateToURL;	import flash.net.URLVariables;	import flash.net.URLRequestMethod;		import src.events.VideoDisplayEvent;	import src.ui.PauseImage;	import src.ui.VideoController;		public class VideoDisplay extends Sprite {				private var videoDisplay:Video;		private var ncConnection:NetConnection;		private var videoStream:NetStream;				private var videoBackground:Sprite;				private var pauseImage:PauseImage;				private var currentVolume:Number;		private var videoPercent:Number;				private var displayWidth:Number;		private var displayHeight:Number;				private var videoInfo:Object;				private var isPlaying:Boolean;		private var isPaused:Boolean;		private var isConnected:Boolean;		private var isUpdatingDisplay:Boolean;		private var metaDataIsLoaded:Boolean;		private var isShowingShareView:Boolean;				private var currentVideo:String;				private var serverVar:String;		private var justification:String;		private var poster:String;				public function VideoDisplay(newWidth:Number, newHeight:Number, newPoster:String="") {						displayWidth = newWidth;			displayHeight = newHeight;						serverVar = "none";						isPlaying = false;			isPaused = false;			metaDataIsLoaded = false;			isUpdatingDisplay = false;			currentVolume = 0.5;			videoPercent = 0;			justification = "normal";						poster = newPoster;						videoBackground = new Sprite();			addChild(videoBackground);						with (videoBackground.graphics) {				clear();				beginFill(0x000000);				drawRect(0, 0, displayWidth, displayHeight);				endFill();			}						videoDisplay = new Video();			addChild(videoDisplay);						if (poster != "" && poster != null) {				pauseImage = new PauseImage(displayWidth, displayHeight, poster);				addChild(pauseImage);			}		}						// PUBLIC INTERFACE				public function videoSeek(per:Number):void {						videoPercent = per;						if (isPlaying) {				videoStream.seek(videoPercent * videoInfo.duration);			}		}				public function chapterSeek(seekPoint:Number):void {						if (isPlaying) {				videoStream.seek(seekPoint);			}		}				public function format(newWidth:Number, newHeight:Number):void {						displayWidth = newWidth;			displayHeight = newHeight;						if (pauseImage) {				pauseImage.pauseWidth = displayWidth;				pauseImage.pauseHeight = displayHeight;			}						with (videoBackground.graphics) {				clear();				beginFill(0x000000);				drawRect(0, 0, displayWidth, displayHeight);				endFill();			}		}				public function muteVideo():void {			currentVolume = 0;			setVolume(currentVolume);		}				public function unmuteVideo():void {			currentVolume = 0.5;			setVolume(currentVolume);		}				public function playVideo():String {						if (isPlaying) {				trace("INFO: VideoDisplay: playVideo: resume");				isPaused = false;				videoStream.resume();			}			else {				trace("INFO: VideoDisplay: playVideo: play: " + currentVideo);				playNewVideo();				isPlaying = true;			}						return currentVideo + " : " + serverVar;		}				public function pauseVideo():void {			trace("INFO: VideoDisplay: playVideo: pause");			isPaused = true;			videoStream.pause();		}				public function videoComplete():void {						if (isUpdatingDisplay) {				stage.removeEventListener(Event.ENTER_FRAME, updateDisplay);				isUpdatingDisplay = false;			}						if (isConnected) {				videoStream.close();				isConnected = false;				isPlaying = false;			}						pauseImage.visible = true;		}				public function setServer(str:String):void {			serverVar = str;		}				public function loadVideo(videoSource:String):String {						if (currentVideo != videoSource) {								if (isUpdatingDisplay) {					stage.removeEventListener(Event.ENTER_FRAME, updateDisplay);					isUpdatingDisplay = false;				}								if (isConnected) {					videoStream.close();					isConnected = false;					isPlaying = false;				}								currentVideo = videoSource;								return currentVideo;			}						return "";		}				private function playNewVideo():void {						trace("INFO: VideoDisplay: playNewVideo");						ncConnection = new NetConnection();			ncConnection.addEventListener(NetStatusEvent.NET_STATUS, netConnectHandler);			ncConnection.addEventListener(AsyncErrorEvent.ASYNC_ERROR, onAsyncError);			ncConnection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError);			ncConnection.addEventListener(IOErrorEvent.IO_ERROR, onIOError);						if (serverVar != "none" && serverVar != "" && serverVar != null) {				ncConnection.client = { onBWDone:bwDone };				ncConnection.connect(serverVar, true);				isConnected = true;				trace("INFO: VideoDisplay: playNewVideo: server: " + serverVar);			}			else {				ncConnection.connect(null);				isConnected = true;				bwDone();				trace("INFO: VideoDisplay: playNewVideo: no server");			}		}				private function onIOError(event:IOErrorEvent):void {			trace("INFO: VideoDisplay: onIOError");		}				private function bwDone():void {						trace("INFO: VideoDisplay: bwDone");			videoStream = new NetStream(ncConnection);			videoStream.addEventListener(NetStatusEvent.NET_STATUS, netStreamHandler);			videoStream.client = { onMetaData:vsMetaData };			videoStream.bufferTime = 10;			videoStream.bufferTimeMax = (60 * 60);			videoStream.inBufferSeek = true;			setVolume(currentVolume);						videoDisplay.attachNetStream(videoStream);			videoDisplay.smoothing = true;						videoStream.play(currentVideo);						dispatchEvent(new VideoDisplayEvent(VideoDisplayEvent.CONNECTION_MADE));		}				private function netConnectHandler(event:NetStatusEvent):void {						trace("INFO: VideoDisplay: netConnectHandler");						switch (event.info.code) {				case "NetConnection.Connect.Success" :					trace("INFO: VideoDisplay: Net Connection: Success");					break;				case "NetConnection.Connect.Failed" :					trace("INFO: VideoDisplay: Net Connection: Failed = " + event.info);					break;				case "NetConnection.Connect.Rejected" :					trace("INFO: VideoDisplay: Net Connection: Rejected");					break;				case "NetConnection.Connect.InvalidApp" :					trace("INFO: VideoDisplay: Net Connection: InvalidApp");					break;				case "NetConnection.Connect.AppShutdown" :					trace("INFO: VideoDisplay: Net Connection: App Shut Down");					break;			}		}				private function netStreamHandler(event:NetStatusEvent):void {						trace(event.info.code);						switch (event.info.code) {					case "NetStream.Buffer.Full" :					trace("INFO: VideoDisplay: NetStream.Buffer.Full");					if (pauseImage) {						pauseImage.visible = false;					}					dispatchEvent(new VideoDisplayEvent(VideoDisplayEvent.VIDEO_LOADED));					break;					case "NetStream.Buffer.Empty" :					trace("INFO: VideoDisplay: NetStream.Buffer.Empty");					if (isPlaying) {						dispatchEvent(new VideoDisplayEvent(VideoDisplayEvent.VIDEO_LOADING));					}					break;					case "NetStream.Play.StreamNotFound" :					trace("INFO: VideoDisplay: NetStream.Play.StreamNotFound");										dispatchEvent(new VideoDisplayEvent(VideoDisplayEvent.VIDEO_ERROR));										break;					case "NetStream.Play.Start" :					trace("INFO: VideoDisplay: NetStream.Play.Start");										if (pauseImage) {						pauseImage.visible = false;					}										dispatchEvent(new VideoDisplayEvent(VideoDisplayEvent.VIDEO_PLAYING));					break;									case "NetStream.Pause.Notify" :					trace("INFO: VideoDisplay: NetStream.pause.Notify");										dispatchEvent(new VideoDisplayEvent(VideoDisplayEvent.VIDEO_PAUSED));					break;									case "NetStream.Seek.Notify" : 					trace("INFO: VideoDisplay: NetStream.Seek.Notify");					dispatchEvent(new VideoDisplayEvent(VideoDisplayEvent.VIDEO_LOADING));					break;					case "NetStream.Play.Stop" :					trace("INFO: VideoDisplay: NetStream.Play.Stop");					break;									case "NetStream.Play.Complete" : 										break;								}		}				private function vsMetaData(info:Object):void {						if (isUpdatingDisplay == false) {				stage.addEventListener(Event.ENTER_FRAME, updateDisplay);				isUpdatingDisplay = true;			}						metaDataIsLoaded = true;						videoInfo = info;						dispatchEvent(new VideoDisplayEvent(VideoDisplayEvent.META_DATA_LOADED, videoInfo.duration));		}				private function update(info:Object, videoStream:NetStream):void {						if (videoStream.time < (info.duration - 1)) {				dispatchEvent(new VideoDisplayEvent(VideoDisplayEvent.PLAY_PROGRESS, videoStream.time, info.duration, videoStream.bufferLength));							}			else if (videoStream.time >= (info.duration - 1)) {				videoStream.close();				isConnected = false;				isPlaying = false;				dispatchEvent(new VideoDisplayEvent(VideoDisplayEvent.VIDEO_COMPLETE));			}		}				public function setVideoFullScreen():void {						justification = "fullScreen";			if (pauseImage) {				pauseImage.pauseWidth = stage.stageWidth;				pauseImage.pauseHeight = stage.stageHeight;			}						with (videoBackground.graphics) {				clear();				beginFill(0x000000);				drawRect(0, 0, stage.stageWidth, stage.stageHeight);				endFill();			}		}				public function setVideoNormalScreen():void {						justification = "normal";						if (pauseImage) {				pauseImage.pauseWidth = displayWidth;				pauseImage.pauseHeight = displayHeight;			}						if (isPlaying) {								if (videoInfo.width > 720) {					videoDisplay.width = displayWidth;					videoDisplay.height = displayWidth * (videoInfo.height/videoInfo.width);				}				else {					videoDisplay.height = displayHeight;					videoDisplay.width = displayHeight * (videoInfo.width/videoInfo.height);				}			}						with (videoBackground.graphics) {				clear();				beginFill(0x000000);				drawRect(0, 0, displayWidth, displayHeight);				endFill();			}		}				private function updateDisplay(e:Event):void {							if (metaDataIsLoaded == true) {								update(videoInfo, videoStream);								if (justification == "normal") {										if (displayWidth/displayHeight < videoInfo.width/videoInfo.height) {						videoDisplay.width = displayWidth;						videoDisplay.height = displayWidth * (videoInfo.height/videoInfo.width);					}					else {						videoDisplay.width = displayHeight * (videoInfo.width/videoInfo.height);						videoDisplay.height = displayHeight ;					}											videoDisplay.y = (displayHeight - videoDisplay.height) / 2;					videoDisplay.x = (displayWidth - videoDisplay.width) / 2;				}				else {					videoDisplay.width = (stage.stageWidth);					videoDisplay.height = videoDisplay.width * (videoInfo.height/videoInfo.width);					videoDisplay.y = stage.stageHeight/2 - videoDisplay.height/2;					videoDisplay.x = stage.stageWidth/2 - videoDisplay.width/2;				}							} else {								if (pauseImage) {										if (justification == "normal") {						pauseImage.pauseWidth = displayWidth;						pauseImage.pauseHeight = displayHeight;					}					else {						pauseImage.pauseWidth = stage.stageWidth;						pauseImage.pauseHeight = stage.stageHeight;					}				}			}		}				private function setVolume(level:Number):void {			var intVolume:Number = level;			var sndTransform = new SoundTransform(intVolume);			videoStream.soundTransform = sndTransform;		}				private function onAsyncError(event:AsyncErrorEvent):void {			trace("INFO: VideoDisplay: Async Error = " + event.text);		}				private function onSecurityError(event:SecurityErrorEvent):void {			trace("INFO: VideoDisplay: Security Error = " + event.text);		}	}}